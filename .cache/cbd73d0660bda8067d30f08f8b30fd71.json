{"dependencies":[{"name":"lodash/assign","loc":{"line":5,"column":23}},{"name":"lodash/max","loc":{"line":9,"column":20}},{"name":"lodash/range","loc":{"line":13,"column":22}},{"name":"lodash/isDate","loc":{"line":17,"column":23}},{"name":"lodash/memoize","loc":{"line":21,"column":24}},{"name":"../../../constants/directions","loc":{"line":25,"column":26}},{"name":"d3-time-format","loc":{"line":27,"column":28}},{"name":"d3-time","loc":{"line":29,"column":22}}],"generated":{"js":"'use strict';\n\nexports.__esModule = true;\n\nvar _assign2 = require('lodash/assign');\n\nvar _assign3 = _interopRequireDefault(_assign2);\n\nvar _max2 = require('lodash/max');\n\nvar _max3 = _interopRequireDefault(_max2);\n\nvar _range2 = require('lodash/range');\n\nvar _range3 = _interopRequireDefault(_range2);\n\nvar _isDate2 = require('lodash/isDate');\n\nvar _isDate3 = _interopRequireDefault(_isDate2);\n\nvar _memoize2 = require('lodash/memoize');\n\nvar _memoize3 = _interopRequireDefault(_memoize2);\n\nvar _directions = require('../../../constants/directions');\n\nvar _d3TimeFormat = require('d3-time-format');\n\nvar _d3Time = require('d3-time');\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Compute day cell size according to current context.\n *\n * @param {number} width\n * @param {number} height\n * @param {number} direction\n * @param {array}  yearRange\n * @param {number} yearSpacing\n * @param {number} daySpacing\n * @param {number} maxWeeks\n * @returns {number}\n */\nvar computeCellSize = function computeCellSize(_ref) {\n    var width = _ref.width,\n        height = _ref.height,\n        direction = _ref.direction,\n        yearRange = _ref.yearRange,\n        yearSpacing = _ref.yearSpacing,\n        daySpacing = _ref.daySpacing,\n        maxWeeks = _ref.maxWeeks;\n\n    var hCellSize = void 0;\n    var vCellSize = void 0;\n\n    if (direction === _directions.DIRECTION_HORIZONTAL) {\n        hCellSize = (width - daySpacing * maxWeeks) / maxWeeks;\n        vCellSize = (height - (yearRange.length - 1) * yearSpacing - yearRange.length * (8 * daySpacing)) / (yearRange.length * 7);\n    } else {\n        hCellSize = (width - (yearRange.length - 1) * yearSpacing - yearRange.length * (8 * daySpacing)) / (yearRange.length * 7);\n        vCellSize = (height - daySpacing * maxWeeks) / maxWeeks;\n    }\n\n    return Math.min(hCellSize, vCellSize);\n};\n\n/**\n * Computes month path and bounding box.\n *\n * @param {Date}   date\n * @param {number} cellSize\n * @param {number} yearIndex\n * @param {number} yearSpacing\n * @param {number} daySpacing\n * @param {string} direction\n * @returns { { path: string, bbox: { x: number, y: number, width: number, height: number } } }\n */\n/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\n\nvar monthPathAndBBox = function monthPathAndBBox(_ref2) {\n    var date = _ref2.date,\n        cellSize = _ref2.cellSize,\n        yearIndex = _ref2.yearIndex,\n        yearSpacing = _ref2.yearSpacing,\n        daySpacing = _ref2.daySpacing,\n        direction = _ref2.direction;\n\n    var t1 = new Date(date.getFullYear(), date.getMonth() + 1, 0); // first day of next month\n    var d0 = date.getDay(); // first day of month\n    var w0 = _d3Time.timeWeek.count((0, _d3Time.timeYear)(date), date); // first week of month\n    var d1 = t1.getDay(); // last day of month\n    var w1 = _d3Time.timeWeek.count((0, _d3Time.timeYear)(t1), t1); // last week of month\n\n    // offset according to year index\n    var xO = 0;\n    var yO = 0;\n    var yearOffset = yearIndex * (7 * (cellSize + daySpacing) + yearSpacing);\n    if (direction === _directions.DIRECTION_HORIZONTAL) {\n        yO = yearOffset;\n    } else {\n        xO = yearOffset;\n    }\n\n    var path = void 0;\n    var bbox = { x: xO, y: yO, width: 0, height: 0 };\n    if (direction === _directions.DIRECTION_HORIZONTAL) {\n        path = ['M' + (xO + (w0 + 1) * (cellSize + daySpacing)) + ',' + (yO + d0 * (cellSize + daySpacing)), 'H' + (xO + w0 * (cellSize + daySpacing)) + 'V' + (yO + 7 * (cellSize + daySpacing)), 'H' + (xO + w1 * (cellSize + daySpacing)) + 'V' + (yO + (d1 + 1) * (cellSize + daySpacing)), 'H' + (xO + (w1 + 1) * (cellSize + daySpacing)) + 'V' + yO, 'H' + (xO + (w0 + 1) * (cellSize + daySpacing)) + 'Z'].join('');\n\n        bbox.x = xO + w0 * (cellSize + daySpacing);\n        bbox.width = (w1 + 1) * (cellSize + daySpacing) - bbox.x;\n        bbox.height = 7 * (cellSize + daySpacing);\n    } else {\n        path = ['M' + (xO + d0 * (cellSize + daySpacing)) + ',' + (yO + (w0 + 1) * (cellSize + daySpacing)), 'H' + xO + 'V' + (yO + (w1 + 1) * (cellSize + daySpacing)), 'H' + (xO + (d1 + 1) * (cellSize + daySpacing)) + 'V' + (yO + w1 * (cellSize + daySpacing)), 'H' + (xO + 7 * (cellSize + daySpacing)) + 'V' + (yO + w0 * (cellSize + daySpacing)), 'H' + (xO + d0 * (cellSize + daySpacing)) + 'Z'].join('');\n\n        bbox.y = yO + w0 * (cellSize + daySpacing);\n        bbox.width = 7 * (cellSize + daySpacing);\n        bbox.height = (w1 + 1) * (cellSize + daySpacing) - bbox.y;\n    }\n\n    return { path: path, bbox: bbox };\n};\n\n/**\n * Creates a memoized version of monthPathAndBBox function.\n */\nvar memoMonthPathAndBBox = (0, _memoize3.default)(monthPathAndBBox, function (_ref3) {\n    var date = _ref3.date,\n        cellSize = _ref3.cellSize,\n        yearIndex = _ref3.yearIndex,\n        yearSpacing = _ref3.yearSpacing,\n        daySpacing = _ref3.daySpacing,\n        direction = _ref3.direction;\n\n    return date.toString() + '.' + cellSize + '.' + yearIndex + '.' + yearSpacing + '.' + daySpacing + '.' + direction;\n});\n\n/**\n * Returns a function to Compute day cell position for horizontal layout.\n *\n * @param {number} cellSize\n * @param {number} yearSpacing\n * @param {number} daySpacing\n * @returns { function(): { x: number, y: number } }\n */\nvar cellPositionHorizontal = function cellPositionHorizontal(cellSize, yearSpacing, daySpacing) {\n    return function (d, yearIndex) {\n        var weekOfYear = _d3Time.timeWeek.count((0, _d3Time.timeYear)(d), d);\n\n        return {\n            x: weekOfYear * (cellSize + daySpacing) + daySpacing / 2,\n            y: d.getDay() * (cellSize + daySpacing) + daySpacing / 2 + yearIndex * (yearSpacing + 7 * (cellSize + daySpacing))\n        };\n    };\n};\n\n/**\n * Returns a function to Compute day cell position for vertical layout.\n *\n * @param {number} cellSize\n * @param {number} yearSpacing\n * @param {number} daySpacing\n * @returns { function(): { x: number, y: number } }\n */\nvar cellPositionVertical = function cellPositionVertical(cellSize, yearSpacing, daySpacing) {\n    return function (d, yearIndex) {\n        var weekOfYear = _d3Time.timeWeek.count((0, _d3Time.timeYear)(d), d);\n\n        return {\n            x: d.getDay() * (cellSize + daySpacing) + daySpacing / 2 + yearIndex * (yearSpacing + 7 * (cellSize + daySpacing)),\n            y: weekOfYear * (cellSize + daySpacing) + daySpacing / 2\n        };\n    };\n};\n\n// used for days range and data matching\nvar dayFormat = (0, _d3TimeFormat.timeFormat)('%Y-%m-%d');\n\n/**\n * This layout is responsible for computing Calendar chart data/positions….\n * It's used for all Calendar related chart components.\n *\n * @param {number}      width\n * @param {number}      height\n * @param {string|Date} from\n * @param {string|Date} to\n * @param {array}       data\n * @param {string}      direction\n * @param {object}      colorScale\n * @param {string}      emptyColor\n * @param {number}      yearSpacing\n * @param {number}      daySpacing\n * @returns {object}\n */\nvar CalendarLayout = function CalendarLayout(_ref4) {\n    var width = _ref4.width,\n        height = _ref4.height,\n        from = _ref4.from,\n        to = _ref4.to,\n        data = _ref4.data,\n        direction = _ref4.direction,\n        colorScale = _ref4.colorScale,\n        emptyColor = _ref4.emptyColor,\n        yearSpacing = _ref4.yearSpacing,\n        daySpacing = _ref4.daySpacing;\n\n    // time related data\n    var fromDate = (0, _isDate3.default)(from) ? from : new Date(from);\n    var toDate = (0, _isDate3.default)(to) ? to : new Date(to);\n\n    var yearRange = (0, _range3.default)(fromDate.getFullYear(), toDate.getFullYear() + 1);\n    var maxWeeks = (0, _max3.default)(yearRange.map(function (year) {\n        return (0, _d3Time.timeWeeks)(new Date(year, 0, 1), new Date(year + 1, 0, 1)).length;\n    })) + 1;\n\n    // ——————————————————————————————————————————————————————————————————————————————————————————————————————\n    // Computes years/months/days\n    // ——————————————————————————————————————————————————————————————————————————————————————————————————————\n    // compute cellSize\n    var cellSize = computeCellSize({\n        width: width,\n        height: height,\n        direction: direction,\n        yearRange: yearRange,\n        yearSpacing: yearSpacing,\n        daySpacing: daySpacing,\n        maxWeeks: maxWeeks\n    });\n\n    // determine day cells positioning function according to layout direction\n    var cellPosition = void 0;\n    if (direction === _directions.DIRECTION_HORIZONTAL) {\n        cellPosition = cellPositionHorizontal(cellSize, yearSpacing, daySpacing);\n    } else {\n        cellPosition = cellPositionVertical(cellSize, yearSpacing, daySpacing);\n    }\n\n    var years = [];\n    var months = [];\n    var days = [];\n\n    yearRange.forEach(function (year, i) {\n        var yearStart = new Date(year, 0, 1);\n        var yearEnd = new Date(year + 1, 0, 1);\n\n        days = days.concat((0, _d3Time.timeDays)(yearStart, yearEnd).map(function (dayDate) {\n            return (0, _assign3.default)({\n                date: dayDate,\n                day: dayFormat(dayDate),\n                size: cellSize\n            }, cellPosition(dayDate, i));\n        }));\n\n        var yearMonths = (0, _d3Time.timeMonths)(yearStart, yearEnd).map(function (monthDate) {\n            return (0, _assign3.default)({ date: monthDate }, memoMonthPathAndBBox({\n                date: monthDate,\n                direction: direction,\n                yearIndex: i,\n                yearSpacing: yearSpacing,\n                daySpacing: daySpacing,\n                cellSize: cellSize\n            }));\n        });\n\n        months = months.concat(yearMonths);\n\n        years.push({\n            year: year,\n            bbox: {\n                x: yearMonths[0].bbox.x,\n                y: yearMonths[0].bbox.y,\n                width: yearMonths[11].bbox.x - yearMonths[0].bbox.x + yearMonths[11].bbox.width,\n                height: yearMonths[11].bbox.y - yearMonths[0].bbox.y + yearMonths[11].bbox.height\n            }\n        });\n    });\n\n    // ——————————————————————————————————————————————————————————————————————————————————————————————————————\n    // Computes days/data intersection\n    // ——————————————————————————————————————————————————————————————————————————————————————————————————————\n    //const color = scalePropToD3Scale(colorScale)\n\n    days.forEach(function (day) {\n        day.color = emptyColor;\n        data.forEach(function (dataDay) {\n            if (dataDay.day === day.day) {\n                day.value = dataDay.value;\n                day.color = colorScale(dataDay.value);\n            }\n        });\n    });\n\n    return { years: years, months: months, days: days, cellSize: cellSize };\n};\n\nexports.default = CalendarLayout;"},"hash":"5f652499e2188b3e4ed019360807c890"}