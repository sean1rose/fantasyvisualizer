{"dependencies":[{"name":"./bridge","loc":{"line":16,"column":22}}],"generated":{"js":"'use strict';\n\nexports.__esModule = true;\nexports.computeAxisTicks = undefined;\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /*\n                                                                                                                                                                                                                                                                   * This file is part of the nivo project.\n                                                                                                                                                                                                                                                                   *\n                                                                                                                                                                                                                                                                   * Copyright 2016-present, RaphaÃ«l Benitte.\n                                                                                                                                                                                                                                                                   *\n                                                                                                                                                                                                                                                                   * For the full copyright and license information, please view the LICENSE\n                                                                                                                                                                                                                                                                   * file that was distributed with this source code.\n                                                                                                                                                                                                                                                                   */\n\n\nvar _bridge = require('./bridge');\n\nvar horizontalPositions = ['top', 'bottom'];\nvar verticalPositions = ['left', 'right'];\n\nvar centerScale = function centerScale(scale) {\n    var bandwidth = scale.bandwidth();\n\n    if (bandwidth === 0) return scale;\n\n    var offset = bandwidth / 2;\n    if (scale.round()) {\n        offset = Math.round(offset);\n    }\n\n    return function (d) {\n        return scale(d) + offset;\n    };\n};\n\n/**\n * @typedef {Object} AxisTick\n * @param {number} x\n * @param {number} y\n * @param {number} lineX\n * @param {number} lineY\n * @param {number} textX\n * @param {number} textY\n */\n\n/**\n * @param {number}                width\n * @param {number}                height\n * @param {string}                _position\n * @param {Function}              scale\n * @param {Array.<string|number>} [tickValues]\n * @param {number}                [tickCount]\n * @param {number}                [tickSize=5]\n * @param {number}                [tickPadding=5]\n * @param {number}                [tickRotation=0]\n * @parem {string}                [engine='svg']\n * @return {{ x: number, y: number, ticks: Array.<AxisTick>, textAlign: string, textBaseline: string }}\n */\nvar computeAxisTicks = exports.computeAxisTicks = function computeAxisTicks(_ref) {\n    var width = _ref.width,\n        height = _ref.height,\n        _position = _ref.position,\n        scale = _ref.scale,\n        tickValues = _ref.tickValues,\n        tickCount = _ref.tickCount,\n        _ref$tickSize = _ref.tickSize,\n        tickSize = _ref$tickSize === undefined ? 5 : _ref$tickSize,\n        _ref$tickPadding = _ref.tickPadding,\n        tickPadding = _ref$tickPadding === undefined ? 5 : _ref$tickPadding,\n        _ref$tickRotation = _ref.tickRotation,\n        tickRotation = _ref$tickRotation === undefined ? 0 : _ref$tickRotation,\n        _ref$engine = _ref.engine,\n        engine = _ref$engine === undefined ? 'svg' : _ref$engine;\n\n    var values = void 0;\n    if (tickValues) values = tickValues;else if (scale.ticks) values = scale.ticks(tickCount);else values = scale.domain();\n\n    var textProps = _bridge.textPropsByEngine[engine];\n\n    var orient = _position;\n    var position = scale.bandwidth ? centerScale(scale) : scale;\n    var line = { lineX: 0, lineY: 0 };\n    var text = { textX: 0, textY: 0 };\n\n    var x = 0;\n    var y = 0;\n    var translate = void 0;\n    var textAlign = textProps.align.center;\n    var textBaseline = textProps.baseline.center;\n\n    if (horizontalPositions.includes(orient)) {\n        translate = function translate(d) {\n            return { x: position(d), y: 0 };\n        };\n\n        line.lineY = tickSize * (orient === 'bottom' ? 1 : -1);\n        text.textY = (tickSize + tickPadding) * (orient === 'bottom' ? 1 : -1);\n\n        if (orient === 'bottom') {\n            y = height;\n            textBaseline = textProps.baseline.top;\n        } else {\n            textBaseline = textProps.baseline.bottom;\n        }\n\n        if (tickRotation === 0) {\n            textAlign = textProps.align.center;\n        } else if (orient === 'bottom' && tickRotation < 0 || orient === 'top' && tickRotation > 0) {\n            textAlign = textProps.align.right;\n            textBaseline = textProps.baseline.center;\n        } else if (orient === 'bottom' && tickRotation > 0 || orient === 'top' && tickRotation < 0) {\n            textAlign = textProps.align.left;\n            textBaseline = textProps.baseline.center;\n        }\n    } else if (verticalPositions.includes(orient)) {\n        translate = function translate(d) {\n            return { x: 0, y: position(d) };\n        };\n\n        line.lineX = tickSize * (orient === 'right' ? 1 : -1);\n        text.textX = (tickSize + tickPadding) * (orient === 'right' ? 1 : -1);\n\n        if (orient === 'right') {\n            x = width;\n            textAlign = textProps.align.left;\n        } else {\n            textAlign = textProps.align.right;\n        }\n    }\n\n    var ticks = values.map(function (value) {\n        return _extends({\n            key: value,\n            value: value\n        }, translate(value), line, text);\n    });\n\n    return {\n        x: x,\n        y: y,\n        ticks: ticks,\n        textAlign: textAlign,\n        textBaseline: textBaseline\n    };\n};"},"hash":"4d740e9748eec925868168920b1a8062"}